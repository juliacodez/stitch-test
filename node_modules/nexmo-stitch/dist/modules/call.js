/*
 * Nexmo Stitch SDK
 *  Call Object Model
 *
 * Copyright (c) Nexmo Inc. 2018
 */

const WildEmitter = require('wildemitter');
const ConversationClientError = require('../conversationClientError');
const logger = require('loglevel');

const NexmoApiError = ConversationClientError.NexmoApiError;
const NexmoClientError = ConversationClientError.NexmoClientError;

/**
 * Conversation Call Object.
 * @class Call
 * @param {Application} application - The Application object.
 * @param {Conversation} conversation - The Conversation object that belongs to this call.
 * @param {Member} from - The member that initiated the call.
 * @property {Application} application -  The Application object that the call belongs to.
 * @property {Conversation} conversation -  The Conversation object that belongs to this call.
 * @property {Member} from - The caller. The member object of the caller ( not a reference to the one in conversation.members)
 * @property {Member[]} to - The callees. The members that receive the call (not a reference to conversation.members)
 * @property {Call.CALL_STATES} CALL_STATES="started" - the available call states
 * @property {Call.MEMBER_CALL_STATES} MEMBER_CALL_STATES - the available member call states
 * @emits Application#member:call
 * @emits Call#member:call:state
 * @emits Call#call:state:changed
 */

/**
 * Call listening for member state changed events.
 *
 * @event Call#member:call:state
 * @property {Member} from - the member that is changed
 * @property {MEMBER_CALL_STATES} state - the new state
 * @property {Event} event -  the actual event
 * @example <caption>listen for member state events</caption>
 *  call.on("member:call:state",(from, state, event) => {
 *              console.log("member: " + member.user.name + " has " + state);
 *       });
 *   });
 */

/**
 * Call listening for call state changed events.
 *
 * @event Call#call:state:changed
 * @property {Call} call -  the actual event
 * @example <caption>listen for member state events</caption>
 *  call.on("call:state:changed",(call) => {
 *              console.log("call: " + call.state);
 *       });
 *   });
 */
class Call {
	constructor(application, conversation, from) {
		this.application = application;
		this.log = logger.getLogger(this.constructor.name);
		this.from = from;
		this.conversation = null;

		/**
		 * Enum for Call states.
		 * @readonly
		 * @enum {string}
		 * @alias Call.CALL_STATES
		 */
		this.CALL_STATES = {
			/** The Call is in started state */
			STARTED: 'started',
			/** The Call is in ringing state */
			RINGING: 'ringing',
			/** The Call is in answered state */
			ANSWERED: 'answered',
			/** The Call is in complete state */
			COMPLETE: 'complete',
			/** The Call is in busy state */
			BUSY: 'busy',
			/** The Call is in timeout state */
			TIMEOUT: 'timeout',
			/** The Call is in unanswered state */
			UNANSWERED: 'unanswered',
			/** The Call is in rejected state */
			REJECTED: 'rejected',
			/** The Call is in failed state */
			FAILED: 'failed'
		};
		Object.freeze(this.CALL_STATES);
		/**
		 * Enum for Call Member states.
		 * @readonly
		 * @alias Call.MEMBER_CALL_STATES
		 * @enum {string}
		 */
		this.MEMBER_CALL_STATES = {
			/** A Member is in ringing state */
			RINGING: 'ringing',
			/** A Member hung up the call */
			HUNGUP: 'hungup',
			/** A Member answered the call */
			ANSWERED: 'answered',
			/** A Member rejected the call */
			REJECTED: 'rejected'
		}
		Object.freeze(this.MEMBER_CALL_STATES);
		this.state = this.CALL_STATES.STARTED;
		this._setupConversationObject(conversation);
		WildEmitter.mixin(Call);
	}

	/**
	 * Attach member event listeners from the conversation
	 * map them to member:call:state events
	 * provided states member: hungup, rejected and answered
	 * @private
	 */
	_attachCallListeners() {
		this.conversation.releaseGroup('call_module');
		this.conversation.on('member:left', 'call_module', (from, event) => {
			let state = null;
			if (from.timestamp.joined) {
				state = this.MEMBER_CALL_STATES.HUNGUP;
			} else {
				state = this.MEMBER_CALL_STATES.REJECTED;
			}
			this.emit('member:call:state', from, state, event);
			this._hangUpIfAllLeft();
		});
		this.conversation.on('member:joined', 'call_module', (from, event) => {
			const state = this.MEMBER_CALL_STATES.ANSWERED;
			this.emit('member:call:state', from, state, event);
		});
		this.conversation.on('member:invited', 'call_module', (from, event) => {
			const state = this.MEMBER_CALL_STATES.RINGING;
			this.emit('member:call:state', from, state, event);
		});
	}

	/**
	 * Go through the members of the conversation and if .me is the only one (JOINED or INVITED)
	 * call call.hangUp().
	 * @returns {Promise} - empty promise or the call.hangUp promise chain
	 * @private
	 */
	_hangUpIfAllLeft() {
		if (!this.conversation.me || this.conversation.me.state === "LEFT" || Object.keys(this.conversation.members).length <= 1) {
			return Promise.resolve();
		}
		for (const member_id in this.conversation.members) {
			if (!this.conversation.members[member_id]) continue;
			const member = this.conversation.members[member_id];
			if (member.state !== "LEFT" && (this.conversation.me.user.id !== member.user.id)) {
				return Promise.resolve();
			}
		}
		return this.hangUp();
	}

	/**
	 * Set the conversation object of the Call
	 * update call.from, and call.to attributes based on the conversation members
	 * @private
	 */
	_setupConversationObject(conversation) {
		if (!conversation) return;
		this.conversation = conversation;
		if (!conversation.me) {
			this.log.debug("missing own member object");
		} else {
			this.to = Object.assign({}, conversation.members);
			if (this.from) {
				delete this.to[this.from.id];
			}
		}
		this._attachCallListeners();
	}

	_setConversationFrom(from) {
		this.from = from;
	}

	_handleStateChange(event = {}) {
		return new Promise((resolve, reject) => {
			switch (event.type) {
				case 'member:joined':
					return this.conversation.media.enable()
						.then((stream) => {
							this.state = this.CALL_STATES.STARTED;
							this.conversation.media.rtcHelper._playAudioStream(stream);
							this.application.emit("call:state:changed", this);
							resolve();
						}).catch(reject);
				case 'member:left':
					if (this.conversation.me.id === event.from) {
						if (this.state !== this.CALL_STATES.ANSWERED) {
							this.state = this.CALL_STATES.UNANSWERED;
							this.application.emit("call:state:changed", this);
						}
					} else {
						if (this.state !== this.CALL_STATES.ANSWERED) {
							this.state = this.CALL_STATES.REJECTED;
							this.application.emit("call:state:changed", this);
						}
					}
					if (this.state === this.CALL_STATES.ANSWERED) {
						this.state = this.CALL_STATES.COMPLETE;
						this.application.emit("call:state:changed", this);
					}
					resolve();
					break;
				case 'member:media':
					if (event.from !== this.conversation.me.id) {
						this.state = this.CALL_STATES.ANSWERED;
						this.application.emit("call:state:changed", this);
					}
					resolve();
					break;
				case 'sip:ringing':
					this.state = this.CALL_STATES.RINGING;
					this.application.emit("call:state:changed", this);
					resolve();
					break;
				case 'sip:hangup':
					switch (event.body.reason.sip_code) {
						case 486:
							this.state = this.CALL_STATES.BUSY;
							break;
						case 487:
							this.state = this.CALL_STATES.TIMEOUT;
							break;
						case 403:
							this.state = this.CALL_STATES.FAILED;
							break;
					}
					this.application.emit("call:state:changed", this);
					resolve();
					break;
				case 'knocking:delete:success':
					this.state = this.CALL_STATES.UNANSWERED;
					this.application.emit("call:state:changed", this);
					resolve();
					break;
				default:
					resolve();
					break;
			}
		});
	}
	/**
	 * Trigger the call flow for the input users.
	 * Create a conversation with prefix name "CALL_"
	 * and invite all the users.
	 * If at least one user is successfully invited, enable the audio.
	 *
	 * @param {string[]} usernames the usernames of the users to call
	 * @returns {Promise[]} an array of the invite promises for the provided usernames
	 * @private
	 */
	createCall(usernames) {
		if (!usernames || !Array.isArray(usernames) || usernames.length === 0) {
			return Promise.reject(new NexmoClientError("error:application:call:params"));
		}

		return this.application.newConversationAndJoin(
			{ display_name: "CALL_" + this.application.me.name + "_" + usernames.join("_").replace(" ", "") })
			.then((conversation) => {
				this.from = conversation.me;
				this.successful_invited_members = [];
				const invites = usernames.map((username) => {
					//check all invites, if at least one is resolved enable audio
					// we need to catch rejections to allow all the chain to go through (all invites)
					// we then catch-reject a promise so that the errors are passing through the end of the chain
					return conversation.inviteWithAudio({ user_name: username })
						.then((member) => {
							this.successful_invited_members.push(member);
							return Promise.resolve(member);
						})
						.catch((error) => {
							this.log.warn(error);
							// resolve the error to allow the promise.all to collect
							// and return all the promises
							return Promise.resolve(error);
						})
				});
				//helper function to process in Promise.all() the failed invites too
				const process_invites = () => {
					if (this.successful_invited_members.length > 0) {
						return conversation.media.enable({ audio: { muted: false, earmuffed: false } })
							.then(() => {
								return Promise.resolve(invites);
							})
					} else {
						return Promise.reject(invites);
					}
				};
				// we need to continue the invites even if one fails,
				// in process_invites we do the check if at least one was successful
				return Promise.all(invites)
					.then(() => {
						this._setupConversationObject(conversation);
						return process_invites();
					});
			});
	}

	/**
	 * Trigger the call flow for the phone call.
	 * Create a knocking event
	 *
	 * @param {string} phoneNumber the phone number to call
	 * @returns {Promise}
	 * @private
	 */
	createPhoneCall(phoneNumber) {
		return new Promise((resolve, reject) => {
			this.application.session.sendRequest({
				type: 'knocking:new',
				body: {
					channel: {
						type: "app",
						from: {
							type: "app"
						},
						to: {
							type: "phone",
							number: phoneNumber
						}
					}
				}
			}, (response) => {
				if (response.type === 'knocking:new:success') {
					resolve(response);
				} else {
					reject(new NexmoApiError(response));
				}
			});
		});
	}
	/**
	 * Hangs up the call
	 *
	 * If there is a knocking active, do a knocking:delete
	 * otherwise
	 * Leave from the conversation
	 * Disable the audio
	 *
	 * @returns {Promise}
	 */
	hangUp() {
		if (!this.knocking_id) {
			return this.conversation.leave();
		} else {
			return new Promise((resolve, reject) => {
				this.application.session.sendRequest({
					type: 'knocking:delete',
					body: {
						knocking_id: this.knocking_id
					}
				}, (response) => {
					if (response.type === 'knocking:delete:success') {
						const call = this.application._call_draft_list.get(this.knocking_id);
						call._handleStateChange(response);
						this.application._call_draft_list.delete(this.knocking_id);
						resolve(response);
					} else {
						if (!this.conversation) {
							this.log.warn("Problem cancelling the call: Knocking cancel failed and Conversation.leave not available");
							resolve();
						} else {
							this.conversation.leave()
								.then(resolve)
								.catch(reject);
							this.log.warn(new NexmoApiError(response));
						}
					}
				});
			});
		}
	}

	/**
	 * Rejects an incoming call
	 * Leave from the conversation that you are invited
	 *
	 * @returns {Promise}
	 */
	reject() {
		if (this.conversation) {
			return this.conversation.leave();
		} else {
			return Promise.reject(new NexmoClientError("error:call:reject"));
		}
	}

	/**
	 * Answers an incoming call
	 * Join the conversation that you are invited
	 *
	 * @returns {Promise}
	 */
	answer() {
		if (this.conversation) {
			return this.conversation.join()
				.then(() => {
					return this.conversation.media.enable();
				});
		} else {
			return Promise.reject(new NexmoClientError("error:call:answer"));
		}
	}
}
module.exports = Call;
