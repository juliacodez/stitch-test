/*
 * Nexmo Stitch SDK
 *  Conversation Cache module
 *
 * Copyright (c) Nexmo Inc. 2017-2018
 */

const Cache_worker = require('./cache-worker.js');
const logger = require('loglevel');

class RTC_Cache {
	constructor(rtc) {
		this.log = logger.getLogger("Cache");
		this.rtc = rtc;

		const cache_worker = new Cache_worker();

		this.worker = null;

		// placeholder object for cached data
		this.events_from_idb = new Map();

		//load token from cache
		let NXMO_user_data = null;
		if (typeof (Storage) !== 'undefined') {
			NXMO_user_data = localStorage.getItem('NXMO_user_data');
			if (NXMO_user_data) {
				this.user_data = JSON.parse(NXMO_user_data);
			}
			this.log.info('auto-relogin is enabled');
		} else {
			this.log.info('auto-relogin could not be enabled');
		}
		if (typeof window !== 'undefined' && !!window.Worker) {
			this.log.info('initialising cache with webWorker');
			this.worker = new Worker(URL.createObjectURL(cache_worker.cache_worker_blob));

			this.attachWorkerListener();
		} else {
			this.log.warn('webWorker is not supported');
			return;
		}
		this.conversations_idb_count = 0;
	}

	init(rtc) {
		if (!this.worker) return;
		rtc.connection.io.on('packet', (packet) => {
			if (!rtc.cache || packet.type !== 2 || packet.data[0] === 'echo') return;
			const response = packet.data[1];
			// Set the type of the response
			response.type = packet.data[0];
			this.log.debug("[<--]", response.type, response);
			this.process_response(response);
		});

		rtc.connection.io.on('reconnect', () => {
			if (this.user_data) {
				rtc.login(rtc.cache.user_data.token);
			}
		});

		this._sendRequest = rtc.sendRequest;
		rtc.sendRequest = (request, callback) => {
			this.process_request(request).then((cached_response) => {
				if (cached_response) {
					return callback(cached_response);
				} else {
					return this._sendRequest.call(this.rtc, request, callback);
				}
			});
		}
		this.log.info('cache initialised');
	}

	attachWorkerListener() {
		this.worker.onmessage = (event) => {
			this.log.debug('[<--] (WebWorker): ', event.type, event.data.worker_action);
			switch (event.data.worker_action) {
				case 'conversations:idb:count':
					this.conversations_idb_count = event.data.conversations_idb_count;
					this.log.debug(`[<--] (WebWorker): number of conversations: ${this.conversations_idb_count}`);
					break;
				case 'events:storage:get':
					this.events_from_idb.set(event.data.cid, event.data);
					break;
			}
			delete event.data.worker_action;
		};
	}

	process_response(response) {
		let skip = false;
		if (!this.worker) return;
		switch (response.type) {
			case 'conversation:events:success':
				// Get the cid from the request object
				response.cid = this.rtc.requests[response.rid].request.cid;

				response.worker_action = 'events:storage:update';
				break;
			case 'conversation:get:success':
				response.worker_action = 'conversations:storage:add';
				break;
			// these events trigger a worker action to update the conversation.events list
			// case of reload
			case 'image':
			// FALLTHROUGH
			case 'text':
				response.worker_action = 'events:storage:add';
				this.events_from_idb.set(response.cid, response);
				break;
			case 'event:delete':
				response.worker_action = 'events:storage:delete';
				this.events_from_idb.delete(response.cid, response);
				break;
			case 'conversation:delete:success':
				response.cid = this.rtc.requests[response.rid].request.cid;
			// FALLTHROUGH
			case 'conversation:delete':
				response.worker_action = 'conversation:storage:delete';
				this.events_from_idb.delete(response.cid, response);
				break;
			case 'session:logged-out':
			// FALLTHROUGH
			case 'session:terminated':
				skip = true;
				this.invalidate();
			default:
				skip = true;
				this.log.debug(`[--] ignoring response: ${response.type}`);
				break;
		}
		if (skip) return;

		this.worker.postMessage(response);
		this.log.debug(`[-->] (WebWorker): ${response.type}`, response);
	}

	process_request(request) {
		switch (request.type) {
			case 'conversation:events':
				if (this.events_from_idb.has(request.cid) && this.events_from_idb.get(request.cid).events) {
					return Promise.resolve(this.events_from_idb.get(request.cid).events);
				} else {
					const event = {
						worker_action: 'events:storage:get',
						cid: request.cid
					};
					this.worker.postMessage(event);
					this.log.debug('[-->] (WebWorker): ', request.type, event);
				}
				break;
		}
		return Promise.resolve();
	}

	updateToken(user_data) {
		if (typeof (Storage) !== 'undefined') {
			localStorage.setItem('NXMO_user_data', JSON.stringify(user_data));
		}
	}

	invalidate() {
		if (!this.worker) return;
		const event = {
			worker_action: 'conversations:invalidate'
		};
		this.worker.postMessage(event);
		if (typeof (Storage) !== 'undefined') {
			localStorage.removeItem('NXMO_user_data');
		}
		this.log.debug('[-->] (WebWorker): ', event.worker_action);
	}
}
module.exports = RTC_Cache;
