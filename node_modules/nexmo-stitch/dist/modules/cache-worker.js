/*
 * Nexmo Stitch SDK
 *  Caching Service worker
 *
 * Copyright (c) Nexmo Inc. 2018
 *
 * Service worker
 * becomes Blob object and is loaded through the createObjectURL
 */

module.exports = class Cache_worker {
	constructor() {
		const worker = {
			get function() {
				return () => {
					var IDBTransaction = self.IDBTransaction || self.webkitIDBTransaction;

					if (IDBTransaction) {
						IDBTransaction.READ_WRITE = IDBTransaction.READ_WRITE || 'readwrite';
						IDBTransaction.READ_ONLY = IDBTransaction.READ_ONLY || 'readonly';
					}

					/***
					 * Create database
					 * */
					var request = indexedDB.open('ConversationClient', 2);
					var dbReady = false;
					var pendingMessages = [];

					request.onupgradeneeded = (e) => {
						// e is an instance of IDBVersionChangeEvent
						var idb = e.target.result;

						//conversations store
						if (idb.objectStoreNames.contains('conversations')) {
							idb.deleteObjectStore('conversations');
						}

						var store = idb.createObjectStore('conversations', {
							keyPath: 'cid'
						});
						// createIndex operations possible to be pefromed on store.createIndex
						// store.createIndex('by_cid', 'cid', { unique: true });

						// conversation list store

						if (idb.objectStoreNames.contains('events')) {
							idb.deleteObjectStore('events');
						}
						var store_list = idb.createObjectStore('events', {
							keyPath: 'cid'
						});
						// createIndex operations possible to be performed on store.createIndex
						// store_list.createIndex('by_name', 'name', { unique: true });


					};

					request.onsuccess = () => { /* add, update, delete, ... */
						dbReady = true;
						pendingMessages.forEach((e) => {
							onmessage(e);
						});
						self.postMessage({
							worker_action: 'db:initialised'
						});
					};
					request.onblocked = () => {
						// console.log('DB open blocked', e);
					};
					request.onerror = () => { /* handle error */
						// console.log(e, 'error in DB', e);
					};
					request.onabort = () => { /* handle error */
						// console.log(e, 'transaction will automatically abort due the failed request', e);
					};
					request.oncomplete = () => {
						// All requests have succeeded and the transaction has committed.
						// console.log('oncomplete', e);
					};
					//worker events
					onmessageerror = (error) => {
						// console.log('on message error invoked', error);
					};
					onmessage = (e) => {
						var tx;
						var conversationStore;
						var eventStore;

						if (!dbReady) {
							// console.log('adding pending request');
							pendingMessages.push(e);
							return;
						}
						// console.log('processing event: ', e.data);

						if (request) {
							// console.log('ww: ', e.data.worker_action);
							switch (e.data.worker_action) {
								case 'conversations:invalidate':
									request = indexedDB.deleteDatabase('ConversationClient');
									close();
									self.postMessage({
										worker_action: 'conversations:invalidate:success',
									});
									break;
								case 'conversations:storage:add':
									tx = request.result.transaction('conversations', IDBTransaction.READ_WRITE);
									conversationStore = tx.objectStore('conversations');
									conversationStore.put({
										cid: e.data.body.id,
										conversation: e.data
									}).onsuccess = () => {
										var countRequest = conversationStore.count();
										countRequest.onsuccess = () => {
											self.postMessage({
												worker_action: 'conversations:idb:count',
												conversations_idb_count: countRequest.result
											});
										};
									};
									break;
								case 'conversation:storage:delete':
									tx = request.result.transaction('events', IDBTransaction.READ_WRITE);
									eventStore = tx.objectStore('events');
									eventStore.delete(e.data.cid).onsuccess = () => {
										tx = request.result.transaction('conversations', IDBTransaction.READ_WRITE);
										conversationStore = tx.objectStore('conversations');
										conversationStore.delete(e.data.cid).onsuccess = () => {
											// console.log('events deleted');
										};
									};
									break;
								case 'events:storage:update': //handle all the event list
									tx = request.result.transaction('events', IDBTransaction.READ_WRITE);
									eventStore = tx.objectStore('events');
									var putCommand = eventStore.put({
										cid: e.data.cid,
										events: e.data
									});
									putCommand.onsuccess = (event) => {
										// console.log('ww: events updated', event);
									};
									putCommand.onerror = (event) => {
										// console.log("ww events: error: " + event);
									};
									break;
								case 'events:storage:delete':
									tx = request.result.transaction('events', IDBTransaction.READ_WRITE);
									eventStore = tx.objectStore('events');
									eventStore.delete(e.data.cid).onsuccess = () => {
										// console.log('events deleted');
									};
									break;
								case 'events:storage:add':
									tx = request.result.transaction('events', IDBTransaction.READ_WRITE);
									eventStore = tx.objectStore('events');
									eventStore.get(e.data.cid).onsuccess = (event) => {
										if (!event.target.result || !event.target.result.events.body) return;
										event.target.result.events.body.push(e.data);
										eventStore.put(event.target.result).onsuccess = () => {
											// console.log('event list is successfully updated');
										};
									};
									break;
								case 'events:storage:get':
									tx = request.result.transaction('events', IDBTransaction.READ_ONLY);
									eventStore = tx.objectStore('events');
									eventStore.get(e.data.cid).onsuccess = (event) => {
										if (!event.target.result) return;
										event.target.result.worker_action = e.data.worker_action;
										self.postMessage(event.target.result);
									};
									break;
							}
						}
					};
				};
			}
		};

		if (typeof Blob !== 'undefined') {
			var code = worker.function.toString();
			code = code.substring(code.indexOf('{') + 1, code.lastIndexOf('}'));
			var cache_worker_blob = new Blob([code], {
				type: 'application/javascript'
			});
			this.cache_worker_blob = cache_worker_blob;
		}
	}
}
