/*
 * Nexmo Stitch SDK
 *  ImageEvent Object Model
 *
 * Copyright (c) Nexmo Inc. 2017-2018
 */
const logger = require('loglevel');

const Event = require('./event');
const Utils = require('./../utils');

const ConversationClientError = require('../conversationClientError');

const NexmoClientError = ConversationClientError.NexmoClientError;

/**
 * An image message
 *
 * @class ImageEvent
 * @extends Event
 */

class ImageEvent extends Event {
    constructor(conversation, params) {
        super(conversation, params);
        this.log = logger.getLogger(this.constructor.name);
        this.type = "image";
        this.conversation = conversation;
        this.state = {
            seen_by: {},
            delivered_to: {}
        };
        if (params && params.body) {
            if (params.body.timestamp)
                this.timestamp = params.body.timestamp;
        }
        Object.assign(this, params);
    }

    /**
     * Set the message status to 'seen'
     */
    seen() {
        return super.seen();
    }

    /**
     * Set the message status to 'delivered'
     */
    delivered() {
        return super.delivered();
    }

    /**
     * Delete the image event
     * @returns {Promise}
     */
    del() {
        return super.del();
    }
    /**
     * Download an Image from Media service //3 representations
     * @param {string} [type="thumbnail"] original, medium, thumbnail,
     * @param {string} [representations=this.body.representations]  the ImageEvent.body for the image to download
     * @returns {string} the dataUrl "data:image/jpeg;base64..."
     * @example <caption>Downloading an image from the imageEvent</caption>
     *                 imageEvent.fetchImage().then((imagedata) => {
     *                      var img = new Image();
     *                      img.onload = function () {
     *                          copyCanvas(img);
     *                          };
     *                      img.src = imagedata;
     *
     *                      // to cancel the request:
     *                      // conversation.abortSendImage(imageRequest);
     *                  });
     */
    fetchImage(type = "thumbnail", imageDataObject = this.body.representations) {
        const url = imageDataObject[type].url;
        return Utils.networkFetch(url)
            .then((response) => {
                const responseArray = new Uint8Array(response);
                // Convert the int array to a binary String
                // We have to use apply() as we are converting an *array*
                // and String.fromCharCode() takes one or more single values, not
                // an array.
                //support large image files (Chunking)
                let res = "";
                const chunk = 8 * 1024;
                let i;
                for (i = 0; i < responseArray.length / chunk; i++) {
                    res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk, (i + 1) * chunk));
                }
                res += String.fromCharCode.apply(null, responseArray.subarray(i * chunk));
                const b64 = btoa(res);
                const dataUrl = "data:image/jpeg;base64," + b64;
                return Promise.resolve(dataUrl);
            }).catch((error) => {
                this.log.warn(error);
                return Promise.reject(new NexmoClientError("error:fetch-image"));
            });
    }
}
module.exports = ImageEvent;
